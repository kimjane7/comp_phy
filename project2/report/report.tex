\documentclass[prb,aps,twocolumn,showpacs,10pt]{revtex4-1}
\pdfoutput=1
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math

%\usepackage{anysize}
\usepackage[colorlinks,hyperindex, urlcolor=blue, linkcolor=blue,citecolor=black, linkbordercolor={.7 .8 .8}]{hyperref}
\usepackage{graphicx}
%\usepackage{tabularx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsbsy}
\usepackage{tikz}
%\usepackage{wrapfig}
%\usepackage{setspace}
%\usepackage{caption}
%\usepackage{fancyhdr}
\usepackage{nicefrac}
\usetikzlibrary{arrows,shapes,positioning}
\newenvironment{psmallmatrix}
  {\left[\begin{matrix}}
  {\end{matrix}\right]}
  
 \usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\newcommand{\etal}{{\it et~al.}}

\graphicspath{{benchmark/}}

\begin{document}

\title {Project 2}

\author{Jane Kim}
\affiliation{Physics 480: Computational Physics}
\date{\today}


\begin{abstract}
\noindent Abstract\\
\end{abstract}



\maketitle

\section{Introduction}

Many problems in physics are difficult, if not impossible, to solve analytically. However, in many cases, they can be reduced to relatively simple eigenvalue problems which can be solved numerically. In this project, we developed an eigenvalue and eigenvector solver using Jacobi's algorithm for real, symmetric matrices in order to solve three different examples of such problems with varying levels of complexity.
\subsection{Buckling Beam}
For the simplest of the three problems, we consider a beam of length $L$, whose vertical displacement in the $y$-direction is $u(x)$ for $x \in [0,L]$. If $R$ is some constant which reflects the properties, such as the rigidity, of the beam and a force $F$ is applied at $x=L$ towards the origin, the vertical displacement $u(x)$ satisfies the differential equation
\begin{equation}
R\frac{d^2 u(x)}{dx^2} = -Fu(x),
\end{equation}
with homogenous boundary conditions $u(0)=u(L)=0$. Since different combinations of the physical paramters $F, R$, and $L$ can yield the same solution, it is beneficial to introduce the dimensionless quantity $\rho = \frac{x}{L}$ to scale the differential equation. Then (1) becomes
\begin{equation}
\frac{d^2 u(\rho)}{d\rho^2} = -\lambda u(\rho),
\end{equation}
where $\lambda = FL^2/R$ and $\rho \in [0,1]$. For a given number of mesh points $N$, we can obtain a discretized approximation to $u(\rho)$ by rewriting (2) as an eigenvalue problem given by
\begin{align}
\label{eqn:eqlabel}
\begin{split}
A\vec{u} &= \lambda \vec{u},
\\
\begin{psmallmatrix} d&a& \\
a&d&a\\
&\ddots&\ddots&\ddots\\
&&a&d&a\\
&&&a&d\\
\end{psmallmatrix}
\begin{psmallmatrix}
u_1\\u_2\\ \vdots \\ u_{N-2}\\ u_{N-1}
\end{psmallmatrix}&=
\lambda
\begin{psmallmatrix}
u_1\\u_2\\ \vdots \\ u_{N-2}\\ u_{N-1}
\end{psmallmatrix},\\
u_i &= u(\rho_i),\\
\rho_i &= ih,\\
\end{split}
\end{align}
where $d = 2/h^2$, $a = -1/h^2$, and $h = 1/N$ is the step size. At the endpoints, $u_0 = u_N = 0$. This Toeplitz matrix has analytic eigenvalues
\begin{equation}
\lambda_i = d+2a\cos \left( \frac{i \pi}{N+1} \right) , \ \ \ i = 1, 2, ..., N-1,
\end{equation}
which we used to check the accuracy of the eigenvalue solver.

\subsection{One Electron Harmonic Oscillator}
Jacobi's algorithm is applicable for any real, symmetric matrix, so the same program we developed to solve the buckling beam problem can be used to solve the time-independent Schr{\"o}dinger equation for one and two electrons in a three-dimensional harmonic oscillator potential. For one electron with $\ell=0$, we substitute $R(r)=u(r)/r$ into the radial equation and introduce a dimensionless variable $\rho = r/\alpha$ to obtain
\begin{equation}
\left( -\frac{\hbar^2}{2m\alpha^2} \frac{d^2}{d\rho^2} + \frac{1}{2}m\omega^2\alpha^2\rho^2 \right) u(\rho) = E u(\rho). 
\end{equation}
By fixing $\alpha=(\hbar/m\omega)^{1/2}$ and letting $\lambda=2m\alpha^2 E/\hbar^2 = 2E/\hbar\omega$, (5) becomes 
\begin{equation}
\left( -\frac{d^2}{d\rho^2} + \rho^2 \right) u(\rho) = \lambda u(\rho).
\end{equation}
The boundary conditions are $u(0)=\lim_{\rho \rightarrow \infty} u(\rho)=0$, but due to the finite nature of discretizing the differential equation, we must define a window $[\rho_{min}, \rho_{max}]$ on which to compute the eigenvalues and eigenvectors. Then the discretized equation is given by
\begin{equation}
-\frac{1}{h^2} u_{i-1} + \left( \frac{2}{h^2} + \rho_i^2 \right) u_i -\frac{1}{h^2} u_{i+1} = \lambda u_i, 
\end{equation}
where $h=(\rho_{max}-\rho_{min})/N$, $\rho_i = \rho_{min} + ih$, $i = 1, ..., N-1$. Therefore, the only difference between this eigenvalue problem and the buckling beam problem is that the diagonal elements have an additional non-constant term $\rho_i^2$. This problem also has analytic eigenvalues given by $\lambda = 3, 7, 11, 15, ...$ .

EIGENVALUE CALCULATIONS ARE MOST ACCURATE WHEN WINDOW CONTAINS VALUES OF RHO FOR WHICH THE CORRESPONDING EIGENVECTOR (OR U(RHO)) IS NOT IDENTICALLY $\approx 0$

\subsection{Two Electron Harmonic Oscillator}

When the repulsive Coulomb interaction is ignored, the Hamiltonian $H_0$ for two electrons in a harmonic oscillator can be written with respect to the center-of-mass coordinate $\mathbf{R}=(\mathbf{r}_1+\mathbf{r}_2)/2$ and the relative coordinate $\mathbf{r}=\mathbf{r}_1-\mathbf{r}_2$:
\begin{align}
\label{eqn:eqlabel}
\begin{split}
H_0(r,R) &= H_0(r) + H_0(R)\\
H_0(r) &=-\frac{\hbar^2}{m} \frac{d^2}{dr^2} + \frac{1}{4} k r^2\\
H_0(R) &= -\frac{\hbar^2}{4m} \frac{d^2}{dR^2} + kR^2
\end{split}
\end{align}
where $k=m\omega^2$. Then with the Coulomb interaction
\begin{equation}
V(r) = \frac{\beta e^2}{r}, \ \ \ \beta e^2 = 1.44 \ \text{eV} \cdot \text{nm}
\end{equation}
the $r$-dependent Schr{\"o}dinger equation is given by
\begin{equation}
H(r)\psi(r)=[H_0(r)+V(r)]\psi(r)=E_r \psi(r)
\end{equation}
As with one electron case, we substitute the dimensionless variable $\rho=r/\alpha$ in (10) to obtain
\begin{equation}
\left( -\frac{d^2}{d\rho^2} + \omega_r^2\rho^2 + \frac{1}{\rho}\right) \psi(\rho) = \lambda\psi(\rho).
\end{equation}
Here, we have fixed $\alpha=\hbar^2/m\beta e^2$ and defined $\lambda = $ 
$m\alpha^2E/\hbar^2$. Thus the two electron case simply adds another term $1/\rho_i$ to the diagonal elements of $A$ from the one electron case. 

\section{METHOD}

Jacobi's rotation algorithm is an iterative method for approximating the eigenvalues and eigenvectors of a real, symmetric, $N\times N$ matrix. Say we have such a matrix  $A$, and it has a non-zero element $a_{k\ell}$ for some $k, \ell = 1,2,...,N$ and $k\neq \ell$. Let $J(k,l,\theta)$ be a rotation matrix of the form
\begin{equation}
J(k,l,\theta) = \begin{psmallmatrix}
&1&\cdots &0 &\cdots &0 &\cdots &0\\
&\vdots& &\vdots & &\vdots & &\vdots\\
&0&\cdots &c &\cdots &s &\cdots &0\\
&\vdots& &\vdots & &\vdots & &\vdots\\
&0&\cdots &-s &\cdots &c &\cdots &0\\
&\vdots& &\vdots & &\vdots & &\vdots\\
&0&\cdots &0 &\cdots &0 &\cdots &1\\
\end{psmallmatrix},
\end{equation}
where $J_{kk}=J_{\ell\ell}=\cos\theta=c$ and $J_{k\ell}=-J_{\ell k}=\sin\theta=s$. This matrix is orthogonal, so for some arbitrary angle $\theta$, conjugation of $A$ by $J(k,\ell,\theta)$ is given by
\begin{equation}
A'=J(k,\ell,\theta)^T A J(k,\ell,\theta),
\end{equation}
where $A'$ has the entries 
\begin{align}
a_{kk}'&=c^2a_{kk}+s^2a_{\ell\ell}-2csa_{k\ell}\\
a_{\ell\ell}'&=s^2a_{kk}+c^2a_{\ell\ell}+2csa_{k\ell}\\
a_{ik}'&=a_{ki}'=ca_{ik}-sa_{i\ell}, \ \ \ i\neq k, i \neq \ell\\
a_{il}'&=a_{li}'=ca_{i\ell}+sa_{ik}, \ \ \ i\neq k, i \neq \ell\\
a_{k\ell}'&=a_{\ell k}'=(c^2-s^2)a_{k\ell}+sc(a_{kk}-a_{\ell\ell})
\end{align}
We can calculate the special angle $\theta$ for which the elements $a_{k\ell}'$ and $a_{\ell k}'$ become zero using equation (18). In this way, Jacobi's algorithm diagonalizes the matrix $A$ by repeatedly applying similarity transformations of the form (13) to "zero out" the off-diagonal elements $a_{k\ell}$. The largest off-diagonal element is chosen to increase efficiency. The eigenvalues of $A$ are the diagonal elements of the resulting matrix.\\

To calculate $\theta$, we set (18) equal to zero to obtain
\begin{equation}
\frac{a_{\ell\ell}-a_{kk}}{a_{k\ell}} = \frac{c^2-s^2}{cs} = \frac{c}{s}-\frac{s}{c} = \frac{1}{t}-t,
\end{equation}
where $\tan\theta=t=s/c$. We define $\tau = (a_{\ell\ell}-a_{kk})/2a_{kl}$ so that (19) can be rewritten as the quadratic equation
\begin{equation}
t^2+2\tau t - 1 = 0,
\end{equation}
which has the analytic solutions $t=-\tau\pm \sqrt{1+\tau^2}$. Once $t$ is known, $c$ and $s$ are calculated using 
\begin{equation}
c = \frac{1}{\sqrt{1+t^2}}, \ \ \  s=tc.
\end{equation}
In addition, the products $c^2, s^2$, and $cs$ are precalculated before applying equations (14) and (15).\\

Suppose the matrix $A$ is (nearly) diagonal after $n$ rotations, i.e. 
\begin{equation}
D=J_n^T \cdots J_2^T J_1^T A J_1 J_2 \cdots J_n
\end{equation}
for some rotation matrices $J_i$ and diagonal matrix $D$. Then the eigenvectors are simply given by the columns of the product $J_1J_2\cdots J_n$.

\section{Implementation}

\subsection{Jacobi's Algorithm}

The bulk of Jacobi's algorithm can be broken down into two parts: the search for the largest off-diagonal element $a_{k\ell}$, called a pivot, followed by the corresponding rotation of the form (13). Accordingly, we developed a function called \texttt{get\_pivot} which stores the indices $k,\ell$ of the largest element of $A$ above the diagonal (since $A$ is symmetric).

\begin{lstlisting}
// jacobi.cpp
void get_pivot(mat& A, int N, int& k, int& l){
	double Aij,max_offdiag = 0.0;
	for(int i = 0; i < N-1; i++){
		for(int j = i+1; j < N; j++){
			Aij = fabs(A(i,j));
			if(Aij > max_offdiag){
				max_offdiag = Aij;
				k = i;
				l = j;
			}
		}
	}
}
\end{lstlisting}

\noindent Meanwhile, another function called \texttt{rotate} carries out the transformation $A'=J(k,\ell,\theta)^TAJ(k,\ell,\theta)$ and right-multiplies a matrix $V$ by $J(k,\ell,\theta)$. $V$ is initialized as the identity matrix before the first rotation so that the columns of the resulting matrix are the eigenvectors of $A$. 

\begin{lstlisting}
// jacobi.cpp
void rotate(mat& A, mat& V, int k, int l, int N){

	// zero out A(k,l)=A(l,k)
	if( A(k,l) != 0.0 ){

		double c, s, t, tau;
		double cc, ss, cs;
		double Aik, Ail, Vik, Vil;
		double Akk = A(k,k), All = A(l,l), Akl = A(k,l);

		// calculate angle of rotation
		tau = 0.5*(All-Akk)/Akl;
		if(tau >= 0.0){ t = -tau+sqrt(1.0+tau*tau); }
		else{ t = -tau-sqrt(1.0+tau*tau); }

		cc = 1.0/(1.0+t*t);
		ss = 1.0-cc;
		cs = t*cc;
		c = sqrt(cc);
		s = t*c;

		// perform rotation
		A(k,l) = 0.0;
		A(l,k) = 0.0;
		A(k,k) = cc*Akk+ss*All-2.0*cs*Akl;
		A(l,l) = ss*Akk+cc*All+2.0*cs*Akl;
		for(int i = 0; i < N; i++){

			if( (i!=k) && (i!=l) ){
				Aik = A(i,k);
				Ail = A(i,l);
				A(i,k) = c*Aik-s*Ail;
				A(i,l) = c*Ail+s*Aik;
				A(k,i) = A(i,k);
				A(l,i) = A(i,l);
			}

			// rotate eigenvectors 
			Vik = V(i,k);
			Vil = V(i,l);
			V(i,k) = c*Vik-s*Vil;
			V(i,l) = s*Vik+c*Vil;
		}
	}

	else{ cout << "ERROR: These elements are already zero!" << endl; } 
}
\end{lstlisting}

\noindent $A$ is considered diagonalized after applying \texttt{get\_pivot} and \texttt{rotate} until the sum of squares of the off-diagonal elements is smaller than some fixed number $\epsilon$. This sum is calculated by a function called \texttt{offdiag\_sq}, which uses fact that $A$ is symmetric to reduce the number of floating point operations by a factor of two. Finally, for ease and readability, Jacobi's algorithm is implemented by calling these three functionsd \texttt{jacobi}

\begin{lstlisting}
// jacobi.cpp 
void jacobi(mat& A, mat& V, int N){

	double epsilon = 1E-8;
	int k, l;

	while(offdiag_sq(A,N) > epsilon){
		get_pivot(A, N, k, l);
		rotate(A, V, k, l, N);
	}
}
\end{lstlisting}

In g

The function \texttt{norm\_sq} calculates the square of the Frobenius norm by simply adding the squares of the diagonal elements of $A$ to \texttt{offdiag\_sq}. The definitions of these four functions, along with others used for printing the results to file, are stored in \texttt{jacobi.cpp}, while the declarations are stored in \texttt{jacobi.h}. 

\subsection{Unit Tests}

There are several tests we can use to check that the program we dev performs as expected. 
Similarity transformations with orthogonal matrices preserve the Frobenius norm,

\section{Results}

Data was collected for five different temperatures below the lambda point and the speed of second sound was calculated using equation (6). The resonance peaks were found manually by searching for local maxima in the lock-in amplitude data. The average frequency difference $\Delta f$ between adjacent resonance peaks and the speed of second sound $u_2$ for each temperature is shown in the table below. The results are shown in FIG. 5. alongside published data from R.J. Donnelly \cite{donnelly.} 

\begin{center}
\begin{figure*}
\includegraphics[scale=0.7]{wvfunc_1e.pdf}

\textit{Figure 1.} The approximate wavefunctions of the lowest three energy states for one electron in a three-dimensional harmonic oscillator potential are plotted above. Here, $\rho$ is the dimensionless variable defined in Section I. B. 
\end{figure*}
\end{center}

The horizontal error bars ($\delta T$) correspond to the variation in temperature during each sweep. The vertical error bars ($\delta u_2$) were calculated with the following:

\begin{equation}
u_2 = 2 L \Delta f = 2 L (f_n-f_{n-1})
\end{equation}
\begin{equation}
\frac{\delta u_2}{u_2} = \sqrt{\left( \frac{\delta L }{L} \right)^2 + \left( \frac{\delta (f_n-f_{n-1}) }{\Delta f} \right)^2}\\ \\
\end{equation}


The error in resonance frequency measurements was determined to be the frequency step size of 1 Hz. So, $\delta (f_n-f_{n-1}) = \sqrt{2}$ Hz. $\delta L$ was estimated as the expected change in the length $L$ due to thermal contraction. The thermal expansion coefficient for brass \cite{toolbox} is $\alpha \approx 18.5 \cdot 10^{-6} K^{-1}$ , so
\begin{equation}
\begin{aligned}
\delta L &\approx \Delta L \\
&= \alpha L \Delta T \\
&\approx(18.5 \cdot 10^{-6}\  K^{-1})(4.0 \ \text{cm})(300 \ K - 2.17 \ K) \\
&= 0.022 \  \text{cm}
\end{aligned}
\end{equation}

All five data points were consistent with the published data \cite{blah}.


\section{Conclusion}
The speed of second sound was measured in HeII for five different temperatures below $T_\lambda$. They agreed with the published data from R.J. Donnelly within the margins of error. We are certain that the peaks we identified were second sound peaks because they appeared only after cooling the liquid nitrogen below the lambda point (FIG. 4). \\


Jacobi algorithm is a brute force way to get eigenvalues, but not very efficient.





\section{Acknowledgements}
I would like to thank my lab partner, Antonius Torode, for taking an entire day to correct our crappy data with me. Special thanks to Jaideep Singh and Johannes Pollanen for providing guidance and insight into the sources of error in our initial attempt of this experiment. 



\newpage
\begin{references}
\bibitem{blah} R.J. Donnelly. "Experimental Superfluidity". University of Chicago Press. 1967. 
\bibitem{toolbox} "Coefficients of Linear Thermal Expansion". The Engineering ToolBox. EngineeringToolBox.com. 
\bibitem{stanford} Otis Chodosh, Jeremy Hiatt, Samir Shah, and Ning Yan. "Second Sound in HeII". Department of Physics, Stanford University. March 21, 2008.
\bibitem{phy} "Second Sound in Superfluid Liquid He". Department of Physics and Astronomy, Michigan State University. PHY 451.
\bibitem{nwe} "Superfluidity". New World Encyclopedia. October 28, 2015. 
\end{references}

\end{document}
